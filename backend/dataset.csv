id,type,title,url,difficulty,questions
680,arrays & hashing,Valid Palindrome II,https://leetcode.com/problems/valid-palindrome-ii/description/,easy,"{
  title: 'Valid Palindrome II',
  description: 'Determine if a string can become a palindrome by deleting at most one character.',
  cards: [
    {
      question: ""What is the Big O time complexity for 'Valid Palindrome II'?"",
      answer: 'O(N), where N is the length of the string. The algorithm involves a single pass with two pointers, and in the worst case, at most two additional passes over a substring of length N/2, resulting in a linear time complexity.'
    },
    {
      question: ""What is the Big O space complexity for 'Valid Palindrome II'?"",
      answer: ""O(1). The algorithm uses a constant amount of extra space for pointers and variables, regardless of the input string's length, assuming substring checks are done by passing indices rather than creating new string objects.""
    },
    {
      question: ""Describe the general algorithm strategy for 'Valid Palindrome II'."",
      answer: 'Use a two-pointer approach, with `left` at the start and `right` at the end. Iterate inwards, moving `left` right and `right` left. If `s[left]` and `s[right]` do not match, it means we must delete one of them. Check two possibilities: (1) if the substring `s[left+1...right]` is a palindrome, OR (2) if the substring `s[left...right-1]` is a palindrome. If either of these subproblems yields a palindrome, then the original string is a valid palindrome after one deletion.'
    }
  ]
}"
42,two pointers,Trapping Rain Water,https://leetcode.com/problems/trapping-rain-water/description/,hard,"{
  title: 'Trapping Rain Water',
  description: 'Given an elevation map represented by an array of non-negative integers, where each bar has a width of 1, compute how much rainwater it can trap after raining.',
  cards: [
    {
      question: 'What is the optimal time complexity for the Trapping Rain Water problem?',
      answer: 'The optimal time complexity is O(N), where N is the number of bars in the elevation map. This can be achieved using a two-pointer approach or by pre-computing maximum left and right heights.'
    },
    {
      question: 'What is the optimal space complexity for the Trapping Rain Water problem?',
      answer: 'The optimal space complexity is O(1). This is achieved using the two-pointer approach, which only requires a few variables to store current maximums and pointers.'
    },
    {
      question: 'What is the general algorithmic strategy to solve the Trapping Rain Water problem efficiently?',
      answer: 'The core strategy is to determine for each position `i` the maximum height of a bar to its left (`left_max`) and to its right (`right_max`). The amount of water trapped above bar `i` is `max(0, min(left_max, right_max) - height[i])`. This can be optimized using a two-pointer approach where you iterate from both ends, maintaining the current maximum height encountered from the left and right, and processing the side that is smaller at each step.'
    }
  ]
}"
226,trees,Invert Binary Tree,https://leetcode.com/problems/invert-binary-tree/description/,easy,"{
  title: 'Invert Binary Tree',
  description: 'Given the root of a binary tree, invert the tree, and return its root.',
  cards: [
    {
      question: 'What is the Big O time complexity for inverting a binary tree?',
      answer: 'O(N), where N is the number of nodes in the tree. We visit each node exactly once to perform a constant amount of work (swapping children).'
    },
    {
      question: 'What is the Big O space complexity for inverting a binary tree?',
      answer: 'O(H), where H is the height of the tree. This space is used by the recursion call stack. In the worst case (a skewed tree), H can be N, leading to O(N) space. In the best case (a balanced tree), H is log N, leading to O(log N) space.'
    },
    {
      question: 'What is the general algorithm strategy to invert a binary tree?',
      answer: 'A recursive Depth-First Search (DFS) approach. For each node, swap its left and right children. Then, recursively call the invert function on its new left child and its new right child. The base case is when a node is null.'
    }
  ]
}"
36,arrays & hashing,Valid Sudoku,https://leetcode.com/problems/valid-sudoku/,medium,"{
  title: 'Valid Sudoku',
  description: 'Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the three Sudoku rules: each row must contain unique digits, each column must contain unique digits, and each of the nine 3x3 sub-boxes must contain unique digits.',
  cards: [
    {
      question: 'What is the Big O time complexity for validating a 9x9 Sudoku board?',
      answer: 'O(1). The board size is fixed at 9x9. We iterate through a constant number of cells (81), and for each cell, we perform constant-time operations (such as hash set insertions and lookups). For a general N x N Sudoku board, the time complexity would be O(N^2).'
    },
    {
      question: 'What is the Big O space complexity for validating a 9x9 Sudoku board?',
      answer: 'O(1). We use three sets of data structures (e.g., arrays of hash sets) to store the digits encountered in each row, column, and 3x3 sub-box. Since there are 9 rows, 9 columns, and 9 sub-boxes, and each set stores at most 9 unique digits, the total space required is constant. For a general N x N Sudoku board, the space complexity would be O(N^2).'
    },
    {
      question: 'Describe the general algorithm strategy to determine if a Sudoku board is valid.',
      answer: ""Iterate through each cell of the 9x9 board. For every cell containing a digit (not '.'), check its validity against three constraints simultaneously: its row, its column, and its 3x3 sub-box. This can be done efficiently using three collections of hash sets (or boolean arrays/bitmasks): one for tracking digits seen in each row, one for each column, and one for each 3x3 sub-box. If a digit is encountered that is already present in its corresponding row's set, column's set, or sub-box's set, the board is invalid. If all cells are processed without any violations, the board is valid.""
    }
  ]
}"
23,linked list,Merge k Sorted Lists,https://leetcode.com/problems/merge-k-sorted-lists/description/,hard,"{
  title: 'Merge k Sorted Lists',
  description: 'Merge k sorted linked lists into one sorted linked list.',
  cards: [
    {
      question: 'What is the optimal time complexity for merging k sorted lists, where N is the total number of elements across all lists and k is the number of lists?',
      answer: 'O(N log k). Using a min-heap (priority queue), each of the N elements is processed once. Each processing step involves a heap operation (insertion or extraction) which takes O(log k) time, as the heap stores at most k elements.'
    },
    {
      question: 'What is the optimal space complexity for merging k sorted lists?',
      answer: 'O(k). This is primarily due to the storage required for the min-heap, which at most holds one node from each of the k lists simultaneously.'
    },
    {
      question: 'Describe a general algorithm strategy to efficiently merge k sorted linked lists.',
      answer: ""The most efficient strategy uses a min-heap (priority queue). Initialize the heap by adding the head node from each of the k non-empty lists. Then, repeatedly extract the smallest node from the heap, append it to your result list, and if the extracted node has a 'next' node in its original list, add that 'next' node to the heap. Continue this process until the heap is empty.""
    }
  ]
}"
55,greedy,Jump Game,https://leetcode.com/problems/jump-game/description/,medium,"{
  title: 'Jump Game',
  description: 'Given an array of non-negative integers `nums`, where `nums[i]` represents the maximum jump length from index `i`, determine if you can reach the last index starting from index `0`.',
  cards: [
    {
      question: 'What is the Big O time complexity of the optimal solution for Jump Game?',
      answer: 'The optimal solution uses a greedy approach, iterating through the array once. This results in a time complexity of O(N), where N is the number of elements in the `nums` array.'
    },
    {
      question: 'What is the Big O space complexity of the optimal solution for Jump Game?',
      answer: 'The optimal greedy solution uses only a few constant extra variables to keep track of the maximum reachable index. Therefore, the space complexity is O(1).'
    },
    {
      question: 'Describe the general algorithm strategy for solving Jump Game optimally.',
      answer: ""The optimal strategy is a greedy approach. Maintain a variable, say `max_reach`, representing the furthest index reachable so far. Iterate from the start of the array. At each index `i`, if `i` is greater than `max_reach`, it means the current position cannot be reached, so we cannot reach the end. Otherwise, update `max_reach` to `max(max_reach, i + nums[i])`. If `max_reach` ever becomes greater than or equal to the last index (`n-1`), then we can reach the end, and we return `true`. If the loop finishes and we haven't returned `true`, it means the end is unreachable.""
    }
  ]
}"
51,backtracking,N-Queens,https://leetcode.com/problems/n-queens/description/,hard,"{
  title: 'N-Queens',
  description: 'The N-Queens puzzle is the problem of placing N non-attacking queens on an NÃ—N chessboard, such that no two queens attack each other.',
  cards: [
    {
      question: 'What is the Big O time complexity for solving the N-Queens problem using a backtracking algorithm?',
      answer: ""The time complexity is approximately O(N!), where N is the size of the chessboard. In the worst case, the algorithm explores branches similar to checking N permutations of placing queens. If optimized with O(1) checks for occupied columns and diagonals, it's closer to O(N!). If checks involve iterating through previously placed queens, it could be O(N * N!).""
    },
    {
      question: 'What is the Big O space complexity for solving the N-Queens problem using a backtracking algorithm?',
      answer: 'The space complexity is O(N). This is primarily due to the recursion stack, which can go N levels deep, and the auxiliary data structures (e.g., an array/list to store queen positions, and boolean arrays/hash sets to track occupied columns and diagonals) which also require O(N) space.'
    },
    {
      question: 'Describe the general algorithm strategy used to solve the N-Queens problem.',
      answer: ""The N-Queens problem is typically solved using a backtracking algorithm. The strategy involves placing queens row by row. For each row, we iterate through all possible columns. If placing a queen at a specific (row, column) position is 'safe' (i.e., it doesn't attack any previously placed queens), we place it and then recursively try to place a queen in the next row. If the recursive call returns successfully, we propagate success. If it fails or we need to find all solutions, we 'backtrack' by removing the queen from the current (row, column) and try the next column in the current row. This process continues until all queens are placed or all possibilities for a given path are exhausted.""
    }
  ]
}"
15,two pointers,3Sum,https://leetcode.com/problems/3sum/description/,medium,"{
  title: '3Sum',
  description: 'Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. The solution set must not contain duplicate triplets.',
  cards: [
    {
      question: 'What is the Big O time complexity for the optimal solution to 3Sum?',
      answer: 'O(N^2), where N is the number of elements in the input array. This comes from O(N log N) for sorting and O(N^2) for the nested loops (one primary loop and one two-pointer scan) to find triplets.'
    },
    {
      question: 'What is the Big O space complexity for the optimal solution to 3Sum?',
      answer: ""O(N) or O(log N), depending on the sorting algorithm used. If an in-place sorting algorithm like Heapsort is used, it's O(1) auxiliary space. However, many built-in sorting functions (e.g., Timsort in Python) can take O(N) auxiliary space in the worst case. The space for storing the output triplets is usually not counted towards auxiliary space complexity.""
    },
    {
      question: 'What is the general algorithm strategy to solve 3Sum?',
      answer: 'First, sort the input array. Then, iterate through the array with a pointer `i`. For each `nums[i]`, use a two-pointer approach (one pointer `left` starting at `i+1` and another `right` at the end of the array) to find two numbers `nums[left]` and `nums[right]` such that `nums[i] + nums[left] + nums[right] == 0`. Adjust `left` and `right` based on whether the sum is less than, greater than, or equal to zero. Remember to skip duplicate elements for `i`, `left`, and `right` to ensure unique triplets in the output.'
    }
  ]
}"
371,bit manipulation,Sum of Two Integers,https://leetcode.com/problems/sum-of-two-integers/description/,medium,"{
  title: 'Sum of Two Integers',
  description: 'Calculate the sum of two integers a and b without using the + and - operators.',
  cards: [
    {
      question: ""What is the Big O time complexity for summing two integers without '+' or '-' operators?"",
      answer: 'The time complexity is O(k), where k is the number of bits in the integer (e.g., 32 for standard integers). Each bitwise operation (XOR, AND, Left Shift) takes constant time. In the worst case, the carry might propagate through all k bits. Since k is a fixed constant for a given data type, it is often considered O(1).'
    },
    {
      question: ""What is the Big O space complexity for summing two integers without '+' or '-' operators?"",
      answer: 'The space complexity is O(1). We only use a few constant extra variables to store the intermediate sum and carry during the bitwise operations, regardless of the magnitude of the input integers.'
    },
    {
      question: ""Describe the general algorithm strategy for summing two integers without '+' or '-' operators."",
      answer: ""The strategy involves using bitwise operations. We use XOR (^) to calculate the sum of bits without considering carries, and AND (&) followed by a left shift (<< 1) to determine and propagate the carries. This process is performed iteratively: 'sum = a ^ b' computes the bits without carry, and 'carry = (a & b) << 1' computes the carries for the next step. The loop continues by updating 'a = sum' and 'b = carry' until 'carry' becomes zero, at which point 'sum' contains the final result.""
    }
  ]
}"